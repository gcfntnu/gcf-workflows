#-*- mode:snakemake -*-
"""ENSEMBL reference genomes

Use ensembl.org for vertebrates and ensemblgenomes for other kingdoms.

0) Check for config custom reference

1) Initialize ensembl from organism (set required configuration : assembly, release numbers)
2) Build urls for downloading files
3) Download files into REF_DIR structure

"""
PROTOCOL = 'https://'

# assembly name lookup table
include:
    'init_ensembl.smk'


if '__' in config['organism']:
    MULTI_ORG = ORG.split('__')
    multi_species = True
else:
    mulit_species = False

def ensembl_lookup(fn, organism=None, assembly=None):
    import gzip
    hits = []
    organism = organism or config['organism']
    if organism in ['NA', 'na', 'N/A', 'n/a', '']:
        return {'assembly': None, 'division': None, 'species': organism}
    release = config['db']['ensembl']['release']
    if not os.path.exists(fn):
        logger.info('ensembl lookupfile for release {} is missing!'.format(release))
        return {'assembly': None, 'division': None, 'species': organism}
    header = ['species', 'assembly', 'division']
    for row in gzip.open(fn).read().decode('utf-8').splitlines():
        els = dict(zip(header, row.split('\t')))
        if els['species'] == organism:
            if config['organism'] in ['homo_sapiens', 'mus_musculus']:
                els['assembly'] = els['assembly'].split('.')[0]
            hits.append(els)
    if len(hits) == 0:
        logger.info('species `{}` not found in ensembl lookup file'.format(organism))
        return {'assembly': None, 'division': None, 'species': organism}
    elif len(hits) > 1:
        logger.warning('multiple hits in ensembl lookup file. Using first hit in vertebrates')
        # some orgs in multiple divisions (c. elegans ,drosophila, yeast)
        for els in hits:
            if els['division'] == 'vertebrates':
               break
    else:
        els = hits[0]
    return els
        
def init_ensembl(els):
    """Set assembly and division from organism
    
    """
    if els is None:
        return config
    for k in ['assembly', 'division']:
        config['db']['ensembl'][k] = els.get(k)
    
    return config

ENS_RELEASE = str(config['db']['ensembl']['release'])
config = init_ensembl(ensembl_lookup(srcdir('tables/ensembl-{}.gz'.format(ENS_RELEASE))))
ENS_DIVISION = config['db']['ensembl']['division'] or ''
ENS_ASSEMBLY = config['db']['ensembl']['assembly'] or ''
if not ENS_ASSEMBLY:
    # no hits in lookup or no valid lookup file
    ref = config['db'].get('reference_db')
    if ref is None:
        logger.info('no reference_db is set in config file. Assuming reference_db is `custom_reference`')
        config['db']['reference_db'] = 'custom_reference'
    elif ref == 'ensembl':
        logger.warning('no hits in ensembl lookup file. Trying reference_db = `custom_reference`')
        config['db']['reference_db'] = 'custom_reference'
    else:
        logger.info('no hits in ensembl lookup file (reference_db={})'.format(ref))
    
            

if ENS_DIVISION == 'vertebrates':
    URL = 'ftp.ensembl.org/pub/release-{}/{{}}/{{}}'.format(ENS_RELEASE)
else:
    ENSG_RELEASE = str(config['db']['ensemblgenomes']['release'])
    URL = 'ftp.ebi.ac.uk/ensemblgenomes/pub/release-{}/{}/{{}}/{{}}'.format(ENSG_RELEASE, ENS_DIVISION)

rule ensembl_genome:
    params:
        proxy = config.get('proxy', {}).get('wget', ''),
        url = join(PROTOCOL + URL.format('fasta', ORG), 'dna'),
        filename = '.'.join([ORG.capitalize(), ENS_ASSEMBLY, 'dna', 'primary_assembly', 'fa', 'gz']) if ORG in ['homo_sapiens', 'mus_musculus'] else '.'.join([ORG.capitalize(), ENS_ASSEMBLY, 'dna', 'toplevel', 'fa', 'gz']),
        release = ENS_RELEASE
    output:
        genome = join(EXT_DIR, 'ensembl', 'release-{}'.format(ENS_RELEASE), ORG, ENS_ASSEMBLY, 'fasta', 'genome.fa')
    threads: 
        24
    log:
        join(EXT_DIR, 'ensembl', 'release-{}'.format(ENS_RELEASE), ORG, ENS_ASSEMBLY, 'logs', 'genome.log')
    shell:
        """
        wget {params.proxy} -O- {params.url}/{params.filename} | gunzip -c >> {output.genome}
        echo "Ensembl DNA,release-{params.release},{params.url}/{params.filename},`date -I`" > {log}
        """

rule ensembl_noncoding:
    params:
        proxy = config.get('proxy', {}).get('wget', ''),
        url = join(PROTOCOL + URL.format('fasta', ORG), 'ncrna'),
        filename = '.'.join([ORG.capitalize(), ENS_ASSEMBLY, 'ncrna', 'fa', 'gz']),
        release = ENS_RELEASE
    output:
        join(EXT_DIR, 'ensembl', 'release-{}'.format(ENS_RELEASE), ORG, ENS_ASSEMBLY, 'fasta', 'ncrna.fa')
    threads: 
        24
    log:
        join(EXT_DIR, 'ensembl', 'release-{}'.format(ENS_RELEASE), ORG, ENS_ASSEMBLY, 'logs', 'ncrna.log')
    shell: 
        """
        wget {params.proxy} -O- {params.url}/{params.filename} | gunzip -c >> {output}
        echo 'Ensembl DNA,release-{params.release},{params.url}/{params.filename},`date -I`' > {log}
        """

rule ensembl_gff:
    params:
        proxy = config.get('proxy', {}).get('wget', ''),
        url = PROTOCOL + URL.format('gff3', ORG),
        filename = '.'.join([ORG.capitalize(), ENS_ASSEMBLY, ENS_RELEASE, 'gff3', 'gz']),
        release = ENS_RELEASE
    output:
        join(EXT_DIR, 'ensembl', 'release-{}'.format(ENS_RELEASE), ORG, ENS_ASSEMBLY, 'anno', '.'.join([ORG, ENS_ASSEMBLY, ENS_RELEASE, 'gff']) )
    threads: 
        24
    log:
        join(EXT_DIR, 'ensembl', 'release-{}'.format(ENS_RELEASE), ORG, ENS_ASSEMBLY, 'logs', 'gff.log')
    shell: 
        """
        wget {params.proxy} -O- {params.url}/{params.filename} | gunzip -c >> {output}
        echo 'Ensembl GFF,release-{params.release},{params.url}/{params.filename},`date -I`' > {log}
        """
        
rule ensembl_gtf:
    params:
        proxy = config.get('proxy', {}).get('wget', ''),
        url = PROTOCOL + URL.format('gtf', ORG),
        filename = '.'.join([ORG.capitalize(), ENS_ASSEMBLY, ENS_RELEASE, 'gtf', 'gz']),
        release = ENS_RELEASE
    output:
        join(EXT_DIR, 'ensembl', 'release-{}'.format(ENS_RELEASE), ORG, ENS_ASSEMBLY, 'anno', '.'.join([ORG, ENS_ASSEMBLY, ENS_RELEASE, 'gtf']))
    threads: 
        24
    log:
        join(EXT_DIR, 'ensembl', 'release-{}'.format(ENS_RELEASE), ORG, ENS_ASSEMBLY, 'logs', 'gtf.log')
    shell: 
        """
        wget {params.proxy} -O- {params.url}/{params.filename} | gunzip -c >> {output}
        echo 'Ensembl GTF,release-{params.release},{params.url}/{params.filename},`date -I`' > {log}
        """

rule ensembl_symlink_genes:
    input:
        join(EXT_DIR, 'ensembl', 'release-{}'.format(ENS_RELEASE), ORG, ENS_ASSEMBLY, 'anno', '.'.join([ORG, ENS_ASSEMBLY, ENS_RELEASE, '{ext}']))
    output:
        join(EXT_DIR, 'ensembl', 'release-{}'.format(ENS_RELEASE), ORG, ENS_ASSEMBLY, 'anno', 'genes.{ext}')
    wildcard_constraints:
        ext = 'g.+f$'
    shell:
        'ln -sr {input} {output}'



## special casing human genome rules for some rules that need the human genome when working in other organisms (mostly contamination checks)
ruleorder: human_ensembl_genome > ensembl_genome
ruleorder: human_ensembl_noncoding > ensembl_noncoding
ruleorder: human_ensembl_gff > ensembl_gff
ruleorder: human_ensembl_gtf > ensembl_gtf

rule human_ensembl_genome:
    params:
        proxy = config.get('proxy', {}).get('wget', ''),
        url = join(PROTOCOL + URL.format('fasta', 'homo_sapiens'), 'dna'),
        filename = '.'.join(['homo_sapiens'.capitalize(), 'GRCh38', 'dna', 'primary_assembly', 'fa', 'gz']),
        release = ENS_RELEASE
    output:
        genome = join(EXT_DIR, 'ensembl', 'release-{}'.format(ENS_RELEASE), 'homo_sapiens', 'GRCh38', 'fasta', 'genome.fa')
    threads: 
        24
    log:
        join(EXT_DIR, 'ensembl', 'release-{}'.format(ENS_RELEASE), 'homo_sapiens', 'GRCh38', 'logs', 'genome.log')
    shell:
        """
        wget {params.proxy} -O- {params.url}/{params.filename} | gunzip -c >> {output.genome}
        echo 'Ensembl DNA,release-{params.release},{params.url}/{params.filename},`date -I`' >> {log}
        """

rule human_ensembl_noncoding:
    params:
        proxy = config.get('proxy', {}).get('wget', ''),
        url = join(PROTOCOL + URL.format('fasta', 'homo_sapiens'), 'ncrna'),
        filename = '.'.join(['homo_sapiens'.capitalize(), 'GRCh38', 'ncrna', 'fa', 'gz']),
        release = ENS_RELEASE
    output:
        join(EXT_DIR, 'ensembl', 'release-{}'.format(ENS_RELEASE), 'homo_sapiens', 'GRCh38', 'fasta', 'ncrna.fa')
    threads: 
        24
    log:
        join(EXT_DIR, 'ensembl', 'release-{}'.format(ENS_RELEASE), 'homo_sapiens', 'GRCh38', 'logs', 'ncrna.log')
    shell: 
        """
        wget {params.proxy} -O- {params.url}/{params.filename} | gunzip -c >> {output}
        echo 'Ensembl DNA,release-{params.release},{params.url}/{params.filename},`date -I`' > {log}
        """

rule human_ensembl_gff:
    params:
        proxy = config.get('proxy', {}).get('wget', ''),
        url = PROTOCOL + URL.format('gff3', 'homo_sapiens'),
        filename = '.'.join(['homo_sapiens'.capitalize(), 'GRCh38', ENS_RELEASE, 'gff3', 'gz']),
        release = ENS_RELEASE
    output:
        join(EXT_DIR, 'ensembl', 'release-{}'.format(ENS_RELEASE), 'homo_sapiens', 'GRCh38', 'anno', '.'.join(['homo_sapiens', 'GRCh38', ENS_RELEASE, 'gff']))
    threads: 
        24
    log:
        join(EXT_DIR, 'ensembl', 'release-{}'.format(ENS_RELEASE), 'homo_sapiens', 'GRCh38', 'logs', 'gff.log')
    shell: 
        """
        wget {params.proxy} -O- {params.url}/{params.filename} | gunzip -c >> {output}
        echo 'Ensembl GFF,release-{params.release},{params.url}/{params.filename},`date -I`' > {log}
        """
        
rule human_ensembl_gtf:
    params:
        proxy = config.get('proxy', {}).get('wget', ''),
        url = PROTOCOL + URL.format('gtf', 'homo_sapiens'),
        filename = '.'.join(['homo_sapiens'.capitalize(), 'GRCh38', ENS_RELEASE, 'gtf', 'gz']),
        release = ENS_RELEASE
    output:
        join(EXT_DIR, 'ensembl', 'release-{}'.format(ENS_RELEASE), 'homo_sapiens', 'GRCh38', 'anno', '.'.join(['homo_sapiens', 'GRCh38', ENS_RELEASE, 'gff']))
    threads: 
        24
    log:
        join(EXT_DIR, 'ensembl', 'release-{}'.format(ENS_RELEASE), 'homo_sapiens', 'GRCh38', 'logs', 'gtf.log')
    shell: 
        """
        wget {params.proxy} -O- {params.url}/{params.filename} | gunzip -c >> {output}
        echo 'Ensembl GTF,release-{params.release},{params.url}/{params.filename},`date -I`' > {log}
        """

rule ensembl_chromosome_map: #other reference_db.db file needs to be included
    input:
        other_ref_index = join(EXT_DIR, "{other_reference_db}", "release-{other_release}", ORG, ENS_ASSEMBLY, "fasta", "genome.fa.fai"),
        ens_ref_index = join(EXT_DIR, "ensembl", "release-" + ENS_RELEASE, ORG, ENS_ASSEMBLY, "fasta", "genome.fa.fai")
    output:
       join(EXT_DIR, 'ensembl', 'release-{}'.format(ENS_RELEASE), ORG, ENS_ASSEMBLY, 'anno', 'ensembl_to_{other_reference_db}_{other_release}_map.txt')
    shell:
        'paste <(cut -f1 {input.ens_ref_index}) <(cut -f1 {input.other_ref_index}) > {output} '



